// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: playlists.sql

package sqlc

import (
	"context"
	"time"

	"github.com/clipset/clipset-go/internal/domain"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addVideoToPlaylist = `-- name: AddVideoToPlaylist :one
INSERT INTO playlist_videos (
    playlist_id, video_id, position, added_by
) VALUES (
    $1, $2, $3, $4
) RETURNING id, playlist_id, video_id, position, added_at, added_by
`

type AddVideoToPlaylistParams struct {
	PlaylistID uuid.UUID   `json:"playlist_id"`
	VideoID    uuid.UUID   `json:"video_id"`
	Position   int32       `json:"position"`
	AddedBy    pgtype.UUID `json:"added_by"`
}

func (q *Queries) AddVideoToPlaylist(ctx context.Context, arg AddVideoToPlaylistParams) (PlaylistVideo, error) {
	row := q.db.QueryRow(ctx, addVideoToPlaylist,
		arg.PlaylistID,
		arg.VideoID,
		arg.Position,
		arg.AddedBy,
	)
	var i PlaylistVideo
	err := row.Scan(
		&i.ID,
		&i.PlaylistID,
		&i.VideoID,
		&i.Position,
		&i.AddedAt,
		&i.AddedBy,
	)
	return i, err
}

const countPlaylistVideos = `-- name: CountPlaylistVideos :one
SELECT COUNT(*) FROM playlist_videos WHERE playlist_id = $1
`

func (q *Queries) CountPlaylistVideos(ctx context.Context, playlistID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countPlaylistVideos, playlistID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserPlaylists = `-- name: CountUserPlaylists :one
SELECT COUNT(*) FROM playlists WHERE created_by = $1
`

func (q *Queries) CountUserPlaylists(ctx context.Context, createdBy uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countUserPlaylists, createdBy)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPlaylist = `-- name: CreatePlaylist :one
INSERT INTO playlists (
    short_id, name, description, created_by, is_public
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, short_id, name, description, created_by, is_public, created_at, updated_at
`

type CreatePlaylistParams struct {
	ShortID     string    `json:"short_id"`
	Name        string    `json:"name"`
	Description *string   `json:"description"`
	CreatedBy   uuid.UUID `json:"created_by"`
	IsPublic    bool      `json:"is_public"`
}

func (q *Queries) CreatePlaylist(ctx context.Context, arg CreatePlaylistParams) (Playlist, error) {
	row := q.db.QueryRow(ctx, createPlaylist,
		arg.ShortID,
		arg.Name,
		arg.Description,
		arg.CreatedBy,
		arg.IsPublic,
	)
	var i Playlist
	err := row.Scan(
		&i.ID,
		&i.ShortID,
		&i.Name,
		&i.Description,
		&i.CreatedBy,
		&i.IsPublic,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const decrementPlaylistPositions = `-- name: DecrementPlaylistPositions :exec
UPDATE playlist_videos 
SET position = position - 1 
WHERE playlist_id = $1 AND position > $2
`

type DecrementPlaylistPositionsParams struct {
	PlaylistID uuid.UUID `json:"playlist_id"`
	Position   int32     `json:"position"`
}

func (q *Queries) DecrementPlaylistPositions(ctx context.Context, arg DecrementPlaylistPositionsParams) error {
	_, err := q.db.Exec(ctx, decrementPlaylistPositions, arg.PlaylistID, arg.Position)
	return err
}

const deletePlaylist = `-- name: DeletePlaylist :exec
DELETE FROM playlists WHERE id = $1
`

func (q *Queries) DeletePlaylist(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deletePlaylist, id)
	return err
}

const getMaxPlaylistPosition = `-- name: GetMaxPlaylistPosition :one
SELECT COALESCE(MAX(position), -1)::int AS max_position FROM playlist_videos WHERE playlist_id = $1
`

func (q *Queries) GetMaxPlaylistPosition(ctx context.Context, playlistID uuid.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, getMaxPlaylistPosition, playlistID)
	var max_position int32
	err := row.Scan(&max_position)
	return max_position, err
}

const getPlaylistByID = `-- name: GetPlaylistByID :one
SELECT id, short_id, name, description, created_by, is_public, created_at, updated_at FROM playlists WHERE id = $1
`

func (q *Queries) GetPlaylistByID(ctx context.Context, id uuid.UUID) (Playlist, error) {
	row := q.db.QueryRow(ctx, getPlaylistByID, id)
	var i Playlist
	err := row.Scan(
		&i.ID,
		&i.ShortID,
		&i.Name,
		&i.Description,
		&i.CreatedBy,
		&i.IsPublic,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPlaylistByShortID = `-- name: GetPlaylistByShortID :one
SELECT id, short_id, name, description, created_by, is_public, created_at, updated_at FROM playlists WHERE short_id = $1
`

func (q *Queries) GetPlaylistByShortID(ctx context.Context, shortID string) (Playlist, error) {
	row := q.db.QueryRow(ctx, getPlaylistByShortID, shortID)
	var i Playlist
	err := row.Scan(
		&i.ID,
		&i.ShortID,
		&i.Name,
		&i.Description,
		&i.CreatedBy,
		&i.IsPublic,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPlaylistVideoEntry = `-- name: GetPlaylistVideoEntry :one
SELECT id, playlist_id, video_id, position, added_at, added_by FROM playlist_videos 
WHERE playlist_id = $1 AND video_id = $2
`

type GetPlaylistVideoEntryParams struct {
	PlaylistID uuid.UUID `json:"playlist_id"`
	VideoID    uuid.UUID `json:"video_id"`
}

func (q *Queries) GetPlaylistVideoEntry(ctx context.Context, arg GetPlaylistVideoEntryParams) (PlaylistVideo, error) {
	row := q.db.QueryRow(ctx, getPlaylistVideoEntry, arg.PlaylistID, arg.VideoID)
	var i PlaylistVideo
	err := row.Scan(
		&i.ID,
		&i.PlaylistID,
		&i.VideoID,
		&i.Position,
		&i.AddedAt,
		&i.AddedBy,
	)
	return i, err
}

const getPlaylistVideos = `-- name: GetPlaylistVideos :many
SELECT 
    pv.id, pv.playlist_id, pv.video_id, pv.position, pv.added_at, pv.added_by,
    v.short_id as video_short_id,
    v.title as video_title,
    v.description as video_description,
    v.thumbnail_filename as video_thumbnail,
    v.duration_seconds as video_duration,
    v.view_count as video_view_count,
    v.processing_status as video_status,
    v.created_at as video_created_at,
    vu.username as video_uploader_username
FROM playlist_videos pv
JOIN videos v ON pv.video_id = v.id
JOIN users vu ON v.uploaded_by = vu.id
WHERE pv.playlist_id = $1
ORDER BY pv.position ASC
`

type GetPlaylistVideosRow struct {
	ID                    uuid.UUID               `json:"id"`
	PlaylistID            uuid.UUID               `json:"playlist_id"`
	VideoID               uuid.UUID               `json:"video_id"`
	Position              int32                   `json:"position"`
	AddedAt               time.Time               `json:"added_at"`
	AddedBy               pgtype.UUID             `json:"added_by"`
	VideoShortID          string                  `json:"video_short_id"`
	VideoTitle            string                  `json:"video_title"`
	VideoDescription      *string                 `json:"video_description"`
	VideoThumbnail        *string                 `json:"video_thumbnail"`
	VideoDuration         *int32                  `json:"video_duration"`
	VideoViewCount        int32                   `json:"video_view_count"`
	VideoStatus           domain.ProcessingStatus `json:"video_status"`
	VideoCreatedAt        time.Time               `json:"video_created_at"`
	VideoUploaderUsername string                  `json:"video_uploader_username"`
}

func (q *Queries) GetPlaylistVideos(ctx context.Context, playlistID uuid.UUID) ([]GetPlaylistVideosRow, error) {
	rows, err := q.db.Query(ctx, getPlaylistVideos, playlistID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPlaylistVideosRow{}
	for rows.Next() {
		var i GetPlaylistVideosRow
		if err := rows.Scan(
			&i.ID,
			&i.PlaylistID,
			&i.VideoID,
			&i.Position,
			&i.AddedAt,
			&i.AddedBy,
			&i.VideoShortID,
			&i.VideoTitle,
			&i.VideoDescription,
			&i.VideoThumbnail,
			&i.VideoDuration,
			&i.VideoViewCount,
			&i.VideoStatus,
			&i.VideoCreatedAt,
			&i.VideoUploaderUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlaylistWithVideos = `-- name: GetPlaylistWithVideos :one
SELECT 
    p.id, p.short_id, p.name, p.description, p.created_by, p.is_public, p.created_at, p.updated_at,
    u.username as creator_username
FROM playlists p
JOIN users u ON p.created_by = u.id
WHERE p.short_id = $1
`

type GetPlaylistWithVideosRow struct {
	ID              uuid.UUID `json:"id"`
	ShortID         string    `json:"short_id"`
	Name            string    `json:"name"`
	Description     *string   `json:"description"`
	CreatedBy       uuid.UUID `json:"created_by"`
	IsPublic        bool      `json:"is_public"`
	CreatedAt       time.Time `json:"created_at"`
	UpdatedAt       time.Time `json:"updated_at"`
	CreatorUsername string    `json:"creator_username"`
}

func (q *Queries) GetPlaylistWithVideos(ctx context.Context, shortID string) (GetPlaylistWithVideosRow, error) {
	row := q.db.QueryRow(ctx, getPlaylistWithVideos, shortID)
	var i GetPlaylistWithVideosRow
	err := row.Scan(
		&i.ID,
		&i.ShortID,
		&i.Name,
		&i.Description,
		&i.CreatedBy,
		&i.IsPublic,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatorUsername,
	)
	return i, err
}

const getPlaylistsByUsername = `-- name: GetPlaylistsByUsername :many
SELECT 
    p.id, p.short_id, p.name, p.description, p.created_by, p.is_public, p.created_at, p.updated_at,
    u.username as creator_username,
    COUNT(pv.id) as video_count,
    (
        SELECT v.thumbnail_filename 
        FROM playlist_videos pv2 
        JOIN videos v ON v.id = pv2.video_id 
        WHERE pv2.playlist_id = p.id 
        ORDER BY pv2.position ASC 
        LIMIT 1
    ) as first_video_thumbnail
FROM playlists p
JOIN users u ON p.created_by = u.id
LEFT JOIN playlist_videos pv ON pv.playlist_id = p.id
WHERE LOWER(u.username) = LOWER($1)
GROUP BY p.id, u.username
ORDER BY p.updated_at DESC
`

type GetPlaylistsByUsernameRow struct {
	ID                  uuid.UUID `json:"id"`
	ShortID             string    `json:"short_id"`
	Name                string    `json:"name"`
	Description         *string   `json:"description"`
	CreatedBy           uuid.UUID `json:"created_by"`
	IsPublic            bool      `json:"is_public"`
	CreatedAt           time.Time `json:"created_at"`
	UpdatedAt           time.Time `json:"updated_at"`
	CreatorUsername     string    `json:"creator_username"`
	VideoCount          int64     `json:"video_count"`
	FirstVideoThumbnail *string   `json:"first_video_thumbnail"`
}

func (q *Queries) GetPlaylistsByUsername(ctx context.Context, lower string) ([]GetPlaylistsByUsernameRow, error) {
	rows, err := q.db.Query(ctx, getPlaylistsByUsername, lower)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPlaylistsByUsernameRow{}
	for rows.Next() {
		var i GetPlaylistsByUsernameRow
		if err := rows.Scan(
			&i.ID,
			&i.ShortID,
			&i.Name,
			&i.Description,
			&i.CreatedBy,
			&i.IsPublic,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatorUsername,
			&i.VideoCount,
			&i.FirstVideoThumbnail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlaylistsContainingVideo = `-- name: GetPlaylistsContainingVideo :many
SELECT 
    p.id, p.short_id, p.name, p.description, p.created_by, p.is_public, p.created_at, p.updated_at,
    u.username as creator_username,
    COUNT(pv.id) as video_count
FROM playlists p
JOIN users u ON p.created_by = u.id
JOIN playlist_videos pv ON pv.playlist_id = p.id
WHERE pv.video_id = $1
AND (p.is_public = TRUE OR p.created_by = $2)
GROUP BY p.id, u.username
ORDER BY p.name ASC
`

type GetPlaylistsContainingVideoParams struct {
	VideoID   uuid.UUID `json:"video_id"`
	CreatedBy uuid.UUID `json:"created_by"`
}

type GetPlaylistsContainingVideoRow struct {
	ID              uuid.UUID `json:"id"`
	ShortID         string    `json:"short_id"`
	Name            string    `json:"name"`
	Description     *string   `json:"description"`
	CreatedBy       uuid.UUID `json:"created_by"`
	IsPublic        bool      `json:"is_public"`
	CreatedAt       time.Time `json:"created_at"`
	UpdatedAt       time.Time `json:"updated_at"`
	CreatorUsername string    `json:"creator_username"`
	VideoCount      int64     `json:"video_count"`
}

func (q *Queries) GetPlaylistsContainingVideo(ctx context.Context, arg GetPlaylistsContainingVideoParams) ([]GetPlaylistsContainingVideoRow, error) {
	rows, err := q.db.Query(ctx, getPlaylistsContainingVideo, arg.VideoID, arg.CreatedBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPlaylistsContainingVideoRow{}
	for rows.Next() {
		var i GetPlaylistsContainingVideoRow
		if err := rows.Scan(
			&i.ID,
			&i.ShortID,
			&i.Name,
			&i.Description,
			&i.CreatedBy,
			&i.IsPublic,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatorUsername,
			&i.VideoCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPlaylistsByUser = `-- name: ListPlaylistsByUser :many
SELECT 
    p.id, p.short_id, p.name, p.description, p.created_by, p.is_public, p.created_at, p.updated_at,
    u.username as creator_username,
    COUNT(pv.id) as video_count,
    (
        SELECT v.thumbnail_filename 
        FROM playlist_videos pv2 
        JOIN videos v ON v.id = pv2.video_id 
        WHERE pv2.playlist_id = p.id 
        ORDER BY pv2.position ASC 
        LIMIT 1
    ) as first_video_thumbnail
FROM playlists p
JOIN users u ON p.created_by = u.id
LEFT JOIN playlist_videos pv ON pv.playlist_id = p.id
WHERE p.created_by = $1
AND (p.is_public = TRUE OR p.created_by = $2)
GROUP BY p.id, u.username
ORDER BY p.updated_at DESC
`

type ListPlaylistsByUserParams struct {
	CreatedBy   uuid.UUID `json:"created_by"`
	CreatedBy_2 uuid.UUID `json:"created_by_2"`
}

type ListPlaylistsByUserRow struct {
	ID                  uuid.UUID `json:"id"`
	ShortID             string    `json:"short_id"`
	Name                string    `json:"name"`
	Description         *string   `json:"description"`
	CreatedBy           uuid.UUID `json:"created_by"`
	IsPublic            bool      `json:"is_public"`
	CreatedAt           time.Time `json:"created_at"`
	UpdatedAt           time.Time `json:"updated_at"`
	CreatorUsername     string    `json:"creator_username"`
	VideoCount          int64     `json:"video_count"`
	FirstVideoThumbnail *string   `json:"first_video_thumbnail"`
}

func (q *Queries) ListPlaylistsByUser(ctx context.Context, arg ListPlaylistsByUserParams) ([]ListPlaylistsByUserRow, error) {
	rows, err := q.db.Query(ctx, listPlaylistsByUser, arg.CreatedBy, arg.CreatedBy_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPlaylistsByUserRow{}
	for rows.Next() {
		var i ListPlaylistsByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.ShortID,
			&i.Name,
			&i.Description,
			&i.CreatedBy,
			&i.IsPublic,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatorUsername,
			&i.VideoCount,
			&i.FirstVideoThumbnail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserPlaylistsWithThumbnail = `-- name: ListUserPlaylistsWithThumbnail :many
SELECT 
    p.id, p.short_id, p.name, p.description, p.created_by, p.is_public, p.created_at, p.updated_at,
    u.username as creator_username,
    COUNT(pv.id) as video_count,
    (
        SELECT v.thumbnail_filename 
        FROM playlist_videos pv2 
        JOIN videos v ON v.id = pv2.video_id 
        WHERE pv2.playlist_id = p.id 
        ORDER BY pv2.position ASC 
        LIMIT 1
    ) as first_video_thumbnail
FROM playlists p
JOIN users u ON p.created_by = u.id
LEFT JOIN playlist_videos pv ON pv.playlist_id = p.id
WHERE p.created_by = $1
GROUP BY p.id, u.username
ORDER BY p.updated_at DESC
`

type ListUserPlaylistsWithThumbnailRow struct {
	ID                  uuid.UUID `json:"id"`
	ShortID             string    `json:"short_id"`
	Name                string    `json:"name"`
	Description         *string   `json:"description"`
	CreatedBy           uuid.UUID `json:"created_by"`
	IsPublic            bool      `json:"is_public"`
	CreatedAt           time.Time `json:"created_at"`
	UpdatedAt           time.Time `json:"updated_at"`
	CreatorUsername     string    `json:"creator_username"`
	VideoCount          int64     `json:"video_count"`
	FirstVideoThumbnail *string   `json:"first_video_thumbnail"`
}

func (q *Queries) ListUserPlaylistsWithThumbnail(ctx context.Context, createdBy uuid.UUID) ([]ListUserPlaylistsWithThumbnailRow, error) {
	rows, err := q.db.Query(ctx, listUserPlaylistsWithThumbnail, createdBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserPlaylistsWithThumbnailRow{}
	for rows.Next() {
		var i ListUserPlaylistsWithThumbnailRow
		if err := rows.Scan(
			&i.ID,
			&i.ShortID,
			&i.Name,
			&i.Description,
			&i.CreatedBy,
			&i.IsPublic,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatorUsername,
			&i.VideoCount,
			&i.FirstVideoThumbnail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const playlistExistsByShortID = `-- name: PlaylistExistsByShortID :one
SELECT EXISTS(SELECT 1 FROM playlists WHERE short_id = $1)
`

func (q *Queries) PlaylistExistsByShortID(ctx context.Context, shortID string) (bool, error) {
	row := q.db.QueryRow(ctx, playlistExistsByShortID, shortID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const removeVideoFromPlaylist = `-- name: RemoveVideoFromPlaylist :exec
DELETE FROM playlist_videos
WHERE playlist_id = $1 AND video_id = $2
`

type RemoveVideoFromPlaylistParams struct {
	PlaylistID uuid.UUID `json:"playlist_id"`
	VideoID    uuid.UUID `json:"video_id"`
}

func (q *Queries) RemoveVideoFromPlaylist(ctx context.Context, arg RemoveVideoFromPlaylistParams) error {
	_, err := q.db.Exec(ctx, removeVideoFromPlaylist, arg.PlaylistID, arg.VideoID)
	return err
}

const updatePlaylist = `-- name: UpdatePlaylist :one
UPDATE playlists SET
    name = COALESCE(NULLIF($2, ''), name),
    description = $3,
    is_public = COALESCE($4, is_public),
    updated_at = NOW()
WHERE id = $1
RETURNING id, short_id, name, description, created_by, is_public, created_at, updated_at
`

type UpdatePlaylistParams struct {
	ID          uuid.UUID   `json:"id"`
	Column2     interface{} `json:"column_2"`
	Description *string     `json:"description"`
	IsPublic    bool        `json:"is_public"`
}

func (q *Queries) UpdatePlaylist(ctx context.Context, arg UpdatePlaylistParams) (Playlist, error) {
	row := q.db.QueryRow(ctx, updatePlaylist,
		arg.ID,
		arg.Column2,
		arg.Description,
		arg.IsPublic,
	)
	var i Playlist
	err := row.Scan(
		&i.ID,
		&i.ShortID,
		&i.Name,
		&i.Description,
		&i.CreatedBy,
		&i.IsPublic,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePlaylistVideoPosition = `-- name: UpdatePlaylistVideoPosition :exec
UPDATE playlist_videos SET position = $3
WHERE playlist_id = $1 AND video_id = $2
`

type UpdatePlaylistVideoPositionParams struct {
	PlaylistID uuid.UUID `json:"playlist_id"`
	VideoID    uuid.UUID `json:"video_id"`
	Position   int32     `json:"position"`
}

func (q *Queries) UpdatePlaylistVideoPosition(ctx context.Context, arg UpdatePlaylistVideoPositionParams) error {
	_, err := q.db.Exec(ctx, updatePlaylistVideoPosition, arg.PlaylistID, arg.VideoID, arg.Position)
	return err
}

const videoInPlaylist = `-- name: VideoInPlaylist :one
SELECT EXISTS(
    SELECT 1 FROM playlist_videos WHERE playlist_id = $1 AND video_id = $2
)
`

type VideoInPlaylistParams struct {
	PlaylistID uuid.UUID `json:"playlist_id"`
	VideoID    uuid.UUID `json:"video_id"`
}

func (q *Queries) VideoInPlaylist(ctx context.Context, arg VideoInPlaylistParams) (bool, error) {
	row := q.db.QueryRow(ctx, videoInPlaylist, arg.PlaylistID, arg.VideoID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
