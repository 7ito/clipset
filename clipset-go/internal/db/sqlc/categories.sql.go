// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: categories.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const categoryExistsByName = `-- name: CategoryExistsByName :one
SELECT EXISTS(SELECT 1 FROM categories WHERE LOWER(name) = LOWER($1))
`

func (q *Queries) CategoryExistsByName(ctx context.Context, lower string) (bool, error) {
	row := q.db.QueryRow(ctx, categoryExistsByName, lower)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const categoryExistsByNameExcludingID = `-- name: CategoryExistsByNameExcludingID :one
SELECT EXISTS(SELECT 1 FROM categories WHERE LOWER(name) = LOWER($1) AND id != $2)
`

type CategoryExistsByNameExcludingIDParams struct {
	Lower string    `json:"lower"`
	ID    uuid.UUID `json:"id"`
}

func (q *Queries) CategoryExistsByNameExcludingID(ctx context.Context, arg CategoryExistsByNameExcludingIDParams) (bool, error) {
	row := q.db.QueryRow(ctx, categoryExistsByNameExcludingID, arg.Lower, arg.ID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const categoryExistsBySlug = `-- name: CategoryExistsBySlug :one
SELECT EXISTS(SELECT 1 FROM categories WHERE slug = $1)
`

func (q *Queries) CategoryExistsBySlug(ctx context.Context, slug string) (bool, error) {
	row := q.db.QueryRow(ctx, categoryExistsBySlug, slug)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createCategory = `-- name: CreateCategory :one
INSERT INTO categories (
    name, slug, description, created_by
) VALUES (
    $1, $2, $3, $4
) RETURNING id, name, slug, description, image_filename, created_by, created_at, updated_at
`

type CreateCategoryParams struct {
	Name        string    `json:"name"`
	Slug        string    `json:"slug"`
	Description *string   `json:"description"`
	CreatedBy   uuid.UUID `json:"created_by"`
}

func (q *Queries) CreateCategory(ctx context.Context, arg CreateCategoryParams) (Category, error) {
	row := q.db.QueryRow(ctx, createCategory,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.CreatedBy,
	)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.ImageFilename,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteCategory = `-- name: DeleteCategory :exec
DELETE FROM categories WHERE id = $1
`

func (q *Queries) DeleteCategory(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteCategory, id)
	return err
}

const deleteCategoryImage = `-- name: DeleteCategoryImage :one
UPDATE categories SET
    image_filename = NULL,
    updated_at = NOW()
WHERE id = $1
RETURNING id, name, slug, description, image_filename, created_by, created_at, updated_at
`

func (q *Queries) DeleteCategoryImage(ctx context.Context, id uuid.UUID) (Category, error) {
	row := q.db.QueryRow(ctx, deleteCategoryImage, id)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.ImageFilename,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCategoryByID = `-- name: GetCategoryByID :one
SELECT id, name, slug, description, image_filename, created_by, created_at, updated_at FROM categories WHERE id = $1
`

func (q *Queries) GetCategoryByID(ctx context.Context, id uuid.UUID) (Category, error) {
	row := q.db.QueryRow(ctx, getCategoryByID, id)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.ImageFilename,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCategoryByIDWithCount = `-- name: GetCategoryByIDWithCount :one
SELECT 
    c.id, c.name, c.slug, c.description, c.image_filename, c.created_by, c.created_at, c.updated_at,
    COUNT(v.id) as video_count
FROM categories c
LEFT JOIN videos v ON v.category_id = c.id AND v.processing_status = 'completed'
WHERE c.id = $1
GROUP BY c.id
`

type GetCategoryByIDWithCountRow struct {
	ID            uuid.UUID `json:"id"`
	Name          string    `json:"name"`
	Slug          string    `json:"slug"`
	Description   *string   `json:"description"`
	ImageFilename *string   `json:"image_filename"`
	CreatedBy     uuid.UUID `json:"created_by"`
	CreatedAt     time.Time `json:"created_at"`
	UpdatedAt     time.Time `json:"updated_at"`
	VideoCount    int64     `json:"video_count"`
}

func (q *Queries) GetCategoryByIDWithCount(ctx context.Context, id uuid.UUID) (GetCategoryByIDWithCountRow, error) {
	row := q.db.QueryRow(ctx, getCategoryByIDWithCount, id)
	var i GetCategoryByIDWithCountRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.ImageFilename,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.VideoCount,
	)
	return i, err
}

const getCategoryBySlug = `-- name: GetCategoryBySlug :one
SELECT id, name, slug, description, image_filename, created_by, created_at, updated_at FROM categories WHERE slug = $1
`

func (q *Queries) GetCategoryBySlug(ctx context.Context, slug string) (Category, error) {
	row := q.db.QueryRow(ctx, getCategoryBySlug, slug)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.ImageFilename,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCategoryBySlugWithCount = `-- name: GetCategoryBySlugWithCount :one
SELECT 
    c.id, c.name, c.slug, c.description, c.image_filename, c.created_by, c.created_at, c.updated_at,
    COUNT(v.id) as video_count
FROM categories c
LEFT JOIN videos v ON v.category_id = c.id AND v.processing_status = 'completed'
WHERE c.slug = $1
GROUP BY c.id
`

type GetCategoryBySlugWithCountRow struct {
	ID            uuid.UUID `json:"id"`
	Name          string    `json:"name"`
	Slug          string    `json:"slug"`
	Description   *string   `json:"description"`
	ImageFilename *string   `json:"image_filename"`
	CreatedBy     uuid.UUID `json:"created_by"`
	CreatedAt     time.Time `json:"created_at"`
	UpdatedAt     time.Time `json:"updated_at"`
	VideoCount    int64     `json:"video_count"`
}

func (q *Queries) GetCategoryBySlugWithCount(ctx context.Context, slug string) (GetCategoryBySlugWithCountRow, error) {
	row := q.db.QueryRow(ctx, getCategoryBySlugWithCount, slug)
	var i GetCategoryBySlugWithCountRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.ImageFilename,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.VideoCount,
	)
	return i, err
}

const listCategories = `-- name: ListCategories :many
SELECT 
    c.id, c.name, c.slug, c.description, c.image_filename, c.created_by, c.created_at, c.updated_at,
    COUNT(v.id) as video_count
FROM categories c
LEFT JOIN videos v ON v.category_id = c.id AND v.processing_status = 'completed'
GROUP BY c.id
ORDER BY c.name ASC
`

type ListCategoriesRow struct {
	ID            uuid.UUID `json:"id"`
	Name          string    `json:"name"`
	Slug          string    `json:"slug"`
	Description   *string   `json:"description"`
	ImageFilename *string   `json:"image_filename"`
	CreatedBy     uuid.UUID `json:"created_by"`
	CreatedAt     time.Time `json:"created_at"`
	UpdatedAt     time.Time `json:"updated_at"`
	VideoCount    int64     `json:"video_count"`
}

func (q *Queries) ListCategories(ctx context.Context) ([]ListCategoriesRow, error) {
	rows, err := q.db.Query(ctx, listCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCategoriesRow{}
	for rows.Next() {
		var i ListCategoriesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.ImageFilename,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.VideoCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCategory = `-- name: UpdateCategory :one
UPDATE categories SET
    name = COALESCE(NULLIF($2, ''), name),
    slug = COALESCE(NULLIF($3, ''), slug),
    description = $4,
    updated_at = NOW()
WHERE id = $1
RETURNING id, name, slug, description, image_filename, created_by, created_at, updated_at
`

type UpdateCategoryParams struct {
	ID          uuid.UUID   `json:"id"`
	Column2     interface{} `json:"column_2"`
	Column3     interface{} `json:"column_3"`
	Description *string     `json:"description"`
}

func (q *Queries) UpdateCategory(ctx context.Context, arg UpdateCategoryParams) (Category, error) {
	row := q.db.QueryRow(ctx, updateCategory,
		arg.ID,
		arg.Column2,
		arg.Column3,
		arg.Description,
	)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.ImageFilename,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCategoryImage = `-- name: UpdateCategoryImage :one
UPDATE categories SET
    image_filename = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, name, slug, description, image_filename, created_by, created_at, updated_at
`

type UpdateCategoryImageParams struct {
	ID            uuid.UUID `json:"id"`
	ImageFilename *string   `json:"image_filename"`
}

func (q *Queries) UpdateCategoryImage(ctx context.Context, arg UpdateCategoryImageParams) (Category, error) {
	row := q.db.QueryRow(ctx, updateCategoryImage, arg.ID, arg.ImageFilename)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.ImageFilename,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
