// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: invitations.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countInvitations = `-- name: CountInvitations :one
SELECT COUNT(*) FROM invitations
`

func (q *Queries) CountInvitations(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countInvitations)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createInvitation = `-- name: CreateInvitation :one
INSERT INTO invitations (
    email, token, created_by, expires_at
) VALUES (
    LOWER($1), $2, $3, $4
) RETURNING id, email, token, created_by, created_at, expires_at, used, used_at
`

type CreateInvitationParams struct {
	Lower     string    `json:"lower"`
	Token     string    `json:"token"`
	CreatedBy uuid.UUID `json:"created_by"`
	ExpiresAt time.Time `json:"expires_at"`
}

func (q *Queries) CreateInvitation(ctx context.Context, arg CreateInvitationParams) (Invitation, error) {
	row := q.db.QueryRow(ctx, createInvitation,
		arg.Lower,
		arg.Token,
		arg.CreatedBy,
		arg.ExpiresAt,
	)
	var i Invitation
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Token,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.Used,
		&i.UsedAt,
	)
	return i, err
}

const deleteInvitation = `-- name: DeleteInvitation :exec
DELETE FROM invitations WHERE id = $1
`

func (q *Queries) DeleteInvitation(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteInvitation, id)
	return err
}

const getInvitationByID = `-- name: GetInvitationByID :one
SELECT id, email, token, created_by, created_at, expires_at, used, used_at FROM invitations WHERE id = $1
`

func (q *Queries) GetInvitationByID(ctx context.Context, id uuid.UUID) (Invitation, error) {
	row := q.db.QueryRow(ctx, getInvitationByID, id)
	var i Invitation
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Token,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.Used,
		&i.UsedAt,
	)
	return i, err
}

const getInvitationByToken = `-- name: GetInvitationByToken :one
SELECT id, email, token, created_by, created_at, expires_at, used, used_at FROM invitations WHERE token = $1
`

func (q *Queries) GetInvitationByToken(ctx context.Context, token string) (Invitation, error) {
	row := q.db.QueryRow(ctx, getInvitationByToken, token)
	var i Invitation
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Token,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.Used,
		&i.UsedAt,
	)
	return i, err
}

const getValidInvitationByToken = `-- name: GetValidInvitationByToken :one
SELECT id, email, token, created_by, created_at, expires_at, used, used_at FROM invitations 
WHERE token = $1 
AND used = FALSE 
AND expires_at > NOW()
`

func (q *Queries) GetValidInvitationByToken(ctx context.Context, token string) (Invitation, error) {
	row := q.db.QueryRow(ctx, getValidInvitationByToken, token)
	var i Invitation
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Token,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.Used,
		&i.UsedAt,
	)
	return i, err
}

const listInvitations = `-- name: ListInvitations :many
SELECT 
    i.id, i.email, i.token, i.created_by, i.created_at, i.expires_at, i.used, i.used_at,
    u.username as creator_username
FROM invitations i
JOIN users u ON i.created_by = u.id
ORDER BY i.created_at DESC
LIMIT $1 OFFSET $2
`

type ListInvitationsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListInvitationsRow struct {
	ID              uuid.UUID          `json:"id"`
	Email           string             `json:"email"`
	Token           string             `json:"token"`
	CreatedBy       uuid.UUID          `json:"created_by"`
	CreatedAt       time.Time          `json:"created_at"`
	ExpiresAt       time.Time          `json:"expires_at"`
	Used            bool               `json:"used"`
	UsedAt          pgtype.Timestamptz `json:"used_at"`
	CreatorUsername string             `json:"creator_username"`
}

func (q *Queries) ListInvitations(ctx context.Context, arg ListInvitationsParams) ([]ListInvitationsRow, error) {
	rows, err := q.db.Query(ctx, listInvitations, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListInvitationsRow{}
	for rows.Next() {
		var i ListInvitationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Token,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.Used,
			&i.UsedAt,
			&i.CreatorUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markInvitationUsed = `-- name: MarkInvitationUsed :exec
UPDATE invitations SET
    used = TRUE,
    used_at = NOW()
WHERE id = $1
`

func (q *Queries) MarkInvitationUsed(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, markInvitationUsed, id)
	return err
}
