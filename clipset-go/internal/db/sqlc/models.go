// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package sqlc

import (
	"database/sql/driver"
	"fmt"
	"time"

	"github.com/clipset/clipset-go/internal/domain"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

type ProcessingStatus string

const (
	ProcessingStatusPending    ProcessingStatus = "pending"
	ProcessingStatusProcessing ProcessingStatus = "processing"
	ProcessingStatusCompleted  ProcessingStatus = "completed"
	ProcessingStatusFailed     ProcessingStatus = "failed"
)

func (e *ProcessingStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ProcessingStatus(s)
	case string:
		*e = ProcessingStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for ProcessingStatus: %T", src)
	}
	return nil
}

type NullProcessingStatus struct {
	ProcessingStatus ProcessingStatus `json:"processing_status"`
	Valid            bool             `json:"valid"` // Valid is true if ProcessingStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullProcessingStatus) Scan(value interface{}) error {
	if value == nil {
		ns.ProcessingStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ProcessingStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullProcessingStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ProcessingStatus), nil
}

type UserRole string

const (
	UserRoleUser  UserRole = "user"
	UserRoleAdmin UserRole = "admin"
)

func (e *UserRole) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UserRole(s)
	case string:
		*e = UserRole(s)
	default:
		return fmt.Errorf("unsupported scan type for UserRole: %T", src)
	}
	return nil
}

type NullUserRole struct {
	UserRole UserRole `json:"user_role"`
	Valid    bool     `json:"valid"` // Valid is true if UserRole is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUserRole) Scan(value interface{}) error {
	if value == nil {
		ns.UserRole, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UserRole.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUserRole) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UserRole), nil
}

type Category struct {
	ID            uuid.UUID `json:"id"`
	Name          string    `json:"name"`
	Slug          string    `json:"slug"`
	Description   *string   `json:"description"`
	ImageFilename *string   `json:"image_filename"`
	CreatedBy     uuid.UUID `json:"created_by"`
	CreatedAt     time.Time `json:"created_at"`
	UpdatedAt     time.Time `json:"updated_at"`
}

type Comment struct {
	ID               uuid.UUID   `json:"id"`
	VideoID          uuid.UUID   `json:"video_id"`
	UserID           uuid.UUID   `json:"user_id"`
	Content          string      `json:"content"`
	TimestampSeconds *int32      `json:"timestamp_seconds"`
	ParentID         pgtype.UUID `json:"parent_id"`
	CreatedAt        time.Time   `json:"created_at"`
	UpdatedAt        time.Time   `json:"updated_at"`
}

type Config struct {
	ID                     int32       `json:"id"`
	MaxFileSizeBytes       int64       `json:"max_file_size_bytes"`
	WeeklyUploadLimitBytes int64       `json:"weekly_upload_limit_bytes"`
	VideoStoragePath       string      `json:"video_storage_path"`
	UseGpuTranscoding      bool        `json:"use_gpu_transcoding"`
	GpuDeviceID            int32       `json:"gpu_device_id"`
	NvencPreset            string      `json:"nvenc_preset"`
	NvencCq                int32       `json:"nvenc_cq"`
	NvencRateControl       string      `json:"nvenc_rate_control"`
	NvencMaxBitrate        string      `json:"nvenc_max_bitrate"`
	NvencBufferSize        string      `json:"nvenc_buffer_size"`
	CpuPreset              string      `json:"cpu_preset"`
	CpuCrf                 int32       `json:"cpu_crf"`
	MaxResolution          string      `json:"max_resolution"`
	AudioBitrate           string      `json:"audio_bitrate"`
	TranscodePresetMode    string      `json:"transcode_preset_mode"`
	VideoOutputFormat      string      `json:"video_output_format"`
	UpdatedAt              time.Time   `json:"updated_at"`
	UpdatedBy              pgtype.UUID `json:"updated_by"`
}

type Invitation struct {
	ID        uuid.UUID          `json:"id"`
	Email     string             `json:"email"`
	Token     string             `json:"token"`
	CreatedBy uuid.UUID          `json:"created_by"`
	CreatedAt time.Time          `json:"created_at"`
	ExpiresAt time.Time          `json:"expires_at"`
	Used      bool               `json:"used"`
	UsedAt    pgtype.Timestamptz `json:"used_at"`
}

type PasswordResetToken struct {
	ID        uuid.UUID `json:"id"`
	UserID    uuid.UUID `json:"user_id"`
	TokenHash string    `json:"token_hash"`
	ExpiresAt time.Time `json:"expires_at"`
	CreatedAt time.Time `json:"created_at"`
}

type Playlist struct {
	ID          uuid.UUID `json:"id"`
	ShortID     string    `json:"short_id"`
	Name        string    `json:"name"`
	Description *string   `json:"description"`
	CreatedBy   uuid.UUID `json:"created_by"`
	IsPublic    bool      `json:"is_public"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
}

type PlaylistVideo struct {
	ID         uuid.UUID   `json:"id"`
	PlaylistID uuid.UUID   `json:"playlist_id"`
	VideoID    uuid.UUID   `json:"video_id"`
	Position   int32       `json:"position"`
	AddedAt    time.Time   `json:"added_at"`
	AddedBy    pgtype.UUID `json:"added_by"`
}

type User struct {
	ID                uuid.UUID       `json:"id"`
	Email             string          `json:"email"`
	Username          string          `json:"username"`
	PasswordHash      string          `json:"password_hash"`
	Role              domain.UserRole `json:"role"`
	CreatedAt         time.Time       `json:"created_at"`
	IsActive          bool            `json:"is_active"`
	AvatarFilename    *string         `json:"avatar_filename"`
	WeeklyUploadBytes int64           `json:"weekly_upload_bytes"`
	LastUploadReset   time.Time       `json:"last_upload_reset"`
}

type Video struct {
	ID                uuid.UUID               `json:"id"`
	ShortID           string                  `json:"short_id"`
	Title             string                  `json:"title"`
	Description       *string                 `json:"description"`
	Filename          string                  `json:"filename"`
	ThumbnailFilename *string                 `json:"thumbnail_filename"`
	OriginalFilename  string                  `json:"original_filename"`
	StoragePath       *string                 `json:"storage_path"`
	FileSizeBytes     int64                   `json:"file_size_bytes"`
	DurationSeconds   *int32                  `json:"duration_seconds"`
	UploadedBy        uuid.UUID               `json:"uploaded_by"`
	CategoryID        pgtype.UUID             `json:"category_id"`
	ViewCount         int32                   `json:"view_count"`
	ProcessingStatus  domain.ProcessingStatus `json:"processing_status"`
	ErrorMessage      *string                 `json:"error_message"`
	CreatedAt         time.Time               `json:"created_at"`
}
