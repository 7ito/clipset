// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: users.sql

package sqlc

import (
	"context"
	"time"

	"github.com/clipset/clipset-go/internal/domain"
	"github.com/google/uuid"
)

const activateUser = `-- name: ActivateUser :exec
UPDATE users SET is_active = TRUE WHERE id = $1
`

func (q *Queries) ActivateUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, activateUser, id)
	return err
}

const countAdmins = `-- name: CountAdmins :one
SELECT COUNT(*) FROM users WHERE role = 'admin' AND is_active = TRUE
`

func (q *Queries) CountAdmins(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countAdmins)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUsers = `-- name: CountUsers :one
SELECT COUNT(*) FROM users
`

func (q *Queries) CountUsers(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countUsers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    email, username, password_hash, role
) VALUES (
    $1, $2, $3, $4
) RETURNING id, email, username, password_hash, role, created_at, is_active, avatar_filename, weekly_upload_bytes, last_upload_reset
`

type CreateUserParams struct {
	Email        string          `json:"email"`
	Username     string          `json:"username"`
	PasswordHash string          `json:"password_hash"`
	Role         domain.UserRole `json:"role"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Email,
		arg.Username,
		arg.PasswordHash,
		arg.Role,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.PasswordHash,
		&i.Role,
		&i.CreatedAt,
		&i.IsActive,
		&i.AvatarFilename,
		&i.WeeklyUploadBytes,
		&i.LastUploadReset,
	)
	return i, err
}

const deactivateUser = `-- name: DeactivateUser :exec
UPDATE users SET is_active = FALSE WHERE id = $1
`

func (q *Queries) DeactivateUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deactivateUser, id)
	return err
}

const deleteUserAvatar = `-- name: DeleteUserAvatar :one
UPDATE users SET avatar_filename = NULL
WHERE id = $1
RETURNING id, email, username, password_hash, role, created_at, is_active, avatar_filename, weekly_upload_bytes, last_upload_reset
`

func (q *Queries) DeleteUserAvatar(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, deleteUserAvatar, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.PasswordHash,
		&i.Role,
		&i.CreatedAt,
		&i.IsActive,
		&i.AvatarFilename,
		&i.WeeklyUploadBytes,
		&i.LastUploadReset,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, username, password_hash, role, created_at, is_active, avatar_filename, weekly_upload_bytes, last_upload_reset FROM users WHERE LOWER(email) = LOWER($1)
`

func (q *Queries) GetUserByEmail(ctx context.Context, lower string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, lower)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.PasswordHash,
		&i.Role,
		&i.CreatedAt,
		&i.IsActive,
		&i.AvatarFilename,
		&i.WeeklyUploadBytes,
		&i.LastUploadReset,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, email, username, password_hash, role, created_at, is_active, avatar_filename, weekly_upload_bytes, last_upload_reset FROM users WHERE id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.PasswordHash,
		&i.Role,
		&i.CreatedAt,
		&i.IsActive,
		&i.AvatarFilename,
		&i.WeeklyUploadBytes,
		&i.LastUploadReset,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, email, username, password_hash, role, created_at, is_active, avatar_filename, weekly_upload_bytes, last_upload_reset FROM users WHERE LOWER(username) = LOWER($1)
`

func (q *Queries) GetUserByUsername(ctx context.Context, lower string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByUsername, lower)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.PasswordHash,
		&i.Role,
		&i.CreatedAt,
		&i.IsActive,
		&i.AvatarFilename,
		&i.WeeklyUploadBytes,
		&i.LastUploadReset,
	)
	return i, err
}

const getUserQuota = `-- name: GetUserQuota :one
SELECT weekly_upload_bytes, last_upload_reset FROM users WHERE id = $1
`

type GetUserQuotaRow struct {
	WeeklyUploadBytes int64     `json:"weekly_upload_bytes"`
	LastUploadReset   time.Time `json:"last_upload_reset"`
}

func (q *Queries) GetUserQuota(ctx context.Context, id uuid.UUID) (GetUserQuotaRow, error) {
	row := q.db.QueryRow(ctx, getUserQuota, id)
	var i GetUserQuotaRow
	err := row.Scan(&i.WeeklyUploadBytes, &i.LastUploadReset)
	return i, err
}

const listUsers = `-- name: ListUsers :many
SELECT id, email, username, password_hash, role, created_at, is_active, avatar_filename, weekly_upload_bytes, last_upload_reset FROM users
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListUsersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]User, error) {
	rows, err := q.db.Query(ctx, listUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Username,
			&i.PasswordHash,
			&i.Role,
			&i.CreatedAt,
			&i.IsActive,
			&i.AvatarFilename,
			&i.WeeklyUploadBytes,
			&i.LastUploadReset,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersDirectory = `-- name: ListUsersDirectory :many
SELECT 
    u.id, u.email, u.username, u.password_hash, u.role, u.created_at, u.is_active, u.avatar_filename, u.weekly_upload_bytes, u.last_upload_reset,
    COUNT(DISTINCT v.id) as video_count,
    COUNT(DISTINCT p.id) as playlist_count
FROM users u
LEFT JOIN videos v ON v.uploaded_by = u.id AND v.processing_status = 'completed'
LEFT JOIN playlists p ON p.created_by = u.id AND p.is_public = TRUE
WHERE u.is_active = TRUE
AND (
    $1::text IS NULL OR $1 = '' OR
    LOWER(u.username) LIKE '%' || LOWER($1) || '%'
)
GROUP BY u.id
ORDER BY
    CASE WHEN $2 = 'newest' THEN u.created_at END DESC,
    CASE WHEN $2 = 'alphabetical' THEN LOWER(u.username) END ASC,
    CASE WHEN $2 = 'videos' THEN COUNT(DISTINCT v.id) END DESC,
    CASE WHEN $2 = 'playlists' THEN COUNT(DISTINCT p.id) END DESC,
    u.created_at DESC
`

type ListUsersDirectoryParams struct {
	Column1 string      `json:"column_1"`
	Column2 interface{} `json:"column_2"`
}

type ListUsersDirectoryRow struct {
	ID                uuid.UUID       `json:"id"`
	Email             string          `json:"email"`
	Username          string          `json:"username"`
	PasswordHash      string          `json:"password_hash"`
	Role              domain.UserRole `json:"role"`
	CreatedAt         time.Time       `json:"created_at"`
	IsActive          bool            `json:"is_active"`
	AvatarFilename    *string         `json:"avatar_filename"`
	WeeklyUploadBytes int64           `json:"weekly_upload_bytes"`
	LastUploadReset   time.Time       `json:"last_upload_reset"`
	VideoCount        int64           `json:"video_count"`
	PlaylistCount     int64           `json:"playlist_count"`
}

func (q *Queries) ListUsersDirectory(ctx context.Context, arg ListUsersDirectoryParams) ([]ListUsersDirectoryRow, error) {
	rows, err := q.db.Query(ctx, listUsersDirectory, arg.Column1, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUsersDirectoryRow{}
	for rows.Next() {
		var i ListUsersDirectoryRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Username,
			&i.PasswordHash,
			&i.Role,
			&i.CreatedAt,
			&i.IsActive,
			&i.AvatarFilename,
			&i.WeeklyUploadBytes,
			&i.LastUploadReset,
			&i.VideoCount,
			&i.PlaylistCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resetAllUploadQuotas = `-- name: ResetAllUploadQuotas :exec
UPDATE users SET 
    weekly_upload_bytes = 0,
    last_upload_reset = NOW()
`

func (q *Queries) ResetAllUploadQuotas(ctx context.Context) error {
	_, err := q.db.Exec(ctx, resetAllUploadQuotas)
	return err
}

const resetUploadQuota = `-- name: ResetUploadQuota :exec
UPDATE users SET 
    weekly_upload_bytes = 0,
    last_upload_reset = NOW()
WHERE id = $1
`

func (q *Queries) ResetUploadQuota(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, resetUploadQuota, id)
	return err
}

const updateUploadQuota = `-- name: UpdateUploadQuota :exec
UPDATE users SET 
    weekly_upload_bytes = weekly_upload_bytes + $2
WHERE id = $1
`

type UpdateUploadQuotaParams struct {
	ID                uuid.UUID `json:"id"`
	WeeklyUploadBytes int64     `json:"weekly_upload_bytes"`
}

func (q *Queries) UpdateUploadQuota(ctx context.Context, arg UpdateUploadQuotaParams) error {
	_, err := q.db.Exec(ctx, updateUploadQuota, arg.ID, arg.WeeklyUploadBytes)
	return err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users SET
    email = COALESCE(NULLIF($2, ''), email),
    username = COALESCE(NULLIF($3, ''), username),
    avatar_filename = $4,
    is_active = COALESCE($5, is_active)
WHERE id = $1
RETURNING id, email, username, password_hash, role, created_at, is_active, avatar_filename, weekly_upload_bytes, last_upload_reset
`

type UpdateUserParams struct {
	ID             uuid.UUID   `json:"id"`
	Column2        interface{} `json:"column_2"`
	Column3        interface{} `json:"column_3"`
	AvatarFilename *string     `json:"avatar_filename"`
	IsActive       bool        `json:"is_active"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUser,
		arg.ID,
		arg.Column2,
		arg.Column3,
		arg.AvatarFilename,
		arg.IsActive,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.PasswordHash,
		&i.Role,
		&i.CreatedAt,
		&i.IsActive,
		&i.AvatarFilename,
		&i.WeeklyUploadBytes,
		&i.LastUploadReset,
	)
	return i, err
}

const updateUserAvatar = `-- name: UpdateUserAvatar :one
UPDATE users SET avatar_filename = $2
WHERE id = $1
RETURNING id, email, username, password_hash, role, created_at, is_active, avatar_filename, weekly_upload_bytes, last_upload_reset
`

type UpdateUserAvatarParams struct {
	ID             uuid.UUID `json:"id"`
	AvatarFilename *string   `json:"avatar_filename"`
}

func (q *Queries) UpdateUserAvatar(ctx context.Context, arg UpdateUserAvatarParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserAvatar, arg.ID, arg.AvatarFilename)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.PasswordHash,
		&i.Role,
		&i.CreatedAt,
		&i.IsActive,
		&i.AvatarFilename,
		&i.WeeklyUploadBytes,
		&i.LastUploadReset,
	)
	return i, err
}

const userExistsByEmail = `-- name: UserExistsByEmail :one
SELECT EXISTS(SELECT 1 FROM users WHERE LOWER(email) = LOWER($1))
`

func (q *Queries) UserExistsByEmail(ctx context.Context, lower string) (bool, error) {
	row := q.db.QueryRow(ctx, userExistsByEmail, lower)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const userExistsByUsername = `-- name: UserExistsByUsername :one
SELECT EXISTS(SELECT 1 FROM users WHERE LOWER(username) = LOWER($1))
`

func (q *Queries) UserExistsByUsername(ctx context.Context, lower string) (bool, error) {
	row := q.db.QueryRow(ctx, userExistsByUsername, lower)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
