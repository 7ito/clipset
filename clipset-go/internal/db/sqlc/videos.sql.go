// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: videos.sql

package sqlc

import (
	"context"
	"time"

	"github.com/clipset/clipset-go/internal/domain"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countUserVideos = `-- name: CountUserVideos :one
SELECT COUNT(*) FROM videos WHERE uploaded_by = $1
`

func (q *Queries) CountUserVideos(ctx context.Context, uploadedBy uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countUserVideos, uploadedBy)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countVideos = `-- name: CountVideos :one
SELECT COUNT(*) FROM videos
WHERE 
    ($1::uuid IS NULL OR category_id = $1)
    AND ($2::text IS NULL OR processing_status::text = $2)
    AND ($3::uuid IS NULL OR uploaded_by = $3)
    AND (
        $4::text IS NULL OR $4 = '' OR
        LOWER(title) LIKE '%' || LOWER($4) || '%' OR
        LOWER(description) LIKE '%' || LOWER($4) || '%'
    )
`

type CountVideosParams struct {
	Column1 uuid.UUID `json:"column_1"`
	Column2 string    `json:"column_2"`
	Column3 uuid.UUID `json:"column_3"`
	Column4 string    `json:"column_4"`
}

func (q *Queries) CountVideos(ctx context.Context, arg CountVideosParams) (int64, error) {
	row := q.db.QueryRow(ctx, countVideos,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countVideosWithAccess = `-- name: CountVideosWithAccess :one
SELECT COUNT(*) FROM videos v
WHERE 
    ($1::bool = true OR v.processing_status = 'completed' OR v.uploaded_by = $2)
    AND ($3::uuid IS NULL OR v.category_id = $3)
    AND ($4::text IS NULL OR v.processing_status::text = $4)
    AND ($5::uuid IS NULL OR v.uploaded_by = $5)
    AND ($6::text IS NULL OR $6 = '' OR LOWER(v.title) LIKE '%' || LOWER($6) || '%')
`

type CountVideosWithAccessParams struct {
	Column1    bool      `json:"column_1"`
	UploadedBy uuid.UUID `json:"uploaded_by"`
	Column3    uuid.UUID `json:"column_3"`
	Column4    string    `json:"column_4"`
	Column5    uuid.UUID `json:"column_5"`
	Column6    string    `json:"column_6"`
}

func (q *Queries) CountVideosWithAccess(ctx context.Context, arg CountVideosWithAccessParams) (int64, error) {
	row := q.db.QueryRow(ctx, countVideosWithAccess,
		arg.Column1,
		arg.UploadedBy,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createVideo = `-- name: CreateVideo :one
INSERT INTO videos (
    short_id, title, description, filename, original_filename,
    file_size_bytes, uploaded_by, category_id, storage_path
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, short_id, title, description, filename, thumbnail_filename, original_filename, storage_path, file_size_bytes, duration_seconds, uploaded_by, category_id, view_count, processing_status, error_message, created_at
`

type CreateVideoParams struct {
	ShortID          string      `json:"short_id"`
	Title            string      `json:"title"`
	Description      *string     `json:"description"`
	Filename         string      `json:"filename"`
	OriginalFilename string      `json:"original_filename"`
	FileSizeBytes    int64       `json:"file_size_bytes"`
	UploadedBy       uuid.UUID   `json:"uploaded_by"`
	CategoryID       pgtype.UUID `json:"category_id"`
	StoragePath      *string     `json:"storage_path"`
}

func (q *Queries) CreateVideo(ctx context.Context, arg CreateVideoParams) (Video, error) {
	row := q.db.QueryRow(ctx, createVideo,
		arg.ShortID,
		arg.Title,
		arg.Description,
		arg.Filename,
		arg.OriginalFilename,
		arg.FileSizeBytes,
		arg.UploadedBy,
		arg.CategoryID,
		arg.StoragePath,
	)
	var i Video
	err := row.Scan(
		&i.ID,
		&i.ShortID,
		&i.Title,
		&i.Description,
		&i.Filename,
		&i.ThumbnailFilename,
		&i.OriginalFilename,
		&i.StoragePath,
		&i.FileSizeBytes,
		&i.DurationSeconds,
		&i.UploadedBy,
		&i.CategoryID,
		&i.ViewCount,
		&i.ProcessingStatus,
		&i.ErrorMessage,
		&i.CreatedAt,
	)
	return i, err
}

const deleteVideo = `-- name: DeleteVideo :exec
DELETE FROM videos WHERE id = $1
`

func (q *Queries) DeleteVideo(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteVideo, id)
	return err
}

const getVideoByID = `-- name: GetVideoByID :one
SELECT id, short_id, title, description, filename, thumbnail_filename, original_filename, storage_path, file_size_bytes, duration_seconds, uploaded_by, category_id, view_count, processing_status, error_message, created_at FROM videos WHERE id = $1
`

func (q *Queries) GetVideoByID(ctx context.Context, id uuid.UUID) (Video, error) {
	row := q.db.QueryRow(ctx, getVideoByID, id)
	var i Video
	err := row.Scan(
		&i.ID,
		&i.ShortID,
		&i.Title,
		&i.Description,
		&i.Filename,
		&i.ThumbnailFilename,
		&i.OriginalFilename,
		&i.StoragePath,
		&i.FileSizeBytes,
		&i.DurationSeconds,
		&i.UploadedBy,
		&i.CategoryID,
		&i.ViewCount,
		&i.ProcessingStatus,
		&i.ErrorMessage,
		&i.CreatedAt,
	)
	return i, err
}

const getVideoByIDWithUploader = `-- name: GetVideoByIDWithUploader :one
SELECT 
    v.id, v.short_id, v.title, v.description, v.filename, v.thumbnail_filename, v.original_filename, v.storage_path, v.file_size_bytes, v.duration_seconds, v.uploaded_by, v.category_id, v.view_count, v.processing_status, v.error_message, v.created_at,
    u.username as uploader_username,
    c.name as category_name,
    c.slug as category_slug
FROM videos v
JOIN users u ON v.uploaded_by = u.id
LEFT JOIN categories c ON v.category_id = c.id
WHERE v.id = $1
`

type GetVideoByIDWithUploaderRow struct {
	ID                uuid.UUID               `json:"id"`
	ShortID           string                  `json:"short_id"`
	Title             string                  `json:"title"`
	Description       *string                 `json:"description"`
	Filename          string                  `json:"filename"`
	ThumbnailFilename *string                 `json:"thumbnail_filename"`
	OriginalFilename  string                  `json:"original_filename"`
	StoragePath       *string                 `json:"storage_path"`
	FileSizeBytes     int64                   `json:"file_size_bytes"`
	DurationSeconds   *int32                  `json:"duration_seconds"`
	UploadedBy        uuid.UUID               `json:"uploaded_by"`
	CategoryID        pgtype.UUID             `json:"category_id"`
	ViewCount         int32                   `json:"view_count"`
	ProcessingStatus  domain.ProcessingStatus `json:"processing_status"`
	ErrorMessage      *string                 `json:"error_message"`
	CreatedAt         time.Time               `json:"created_at"`
	UploaderUsername  string                  `json:"uploader_username"`
	CategoryName      *string                 `json:"category_name"`
	CategorySlug      *string                 `json:"category_slug"`
}

// Get video by UUID with uploader and category info
func (q *Queries) GetVideoByIDWithUploader(ctx context.Context, id uuid.UUID) (GetVideoByIDWithUploaderRow, error) {
	row := q.db.QueryRow(ctx, getVideoByIDWithUploader, id)
	var i GetVideoByIDWithUploaderRow
	err := row.Scan(
		&i.ID,
		&i.ShortID,
		&i.Title,
		&i.Description,
		&i.Filename,
		&i.ThumbnailFilename,
		&i.OriginalFilename,
		&i.StoragePath,
		&i.FileSizeBytes,
		&i.DurationSeconds,
		&i.UploadedBy,
		&i.CategoryID,
		&i.ViewCount,
		&i.ProcessingStatus,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UploaderUsername,
		&i.CategoryName,
		&i.CategorySlug,
	)
	return i, err
}

const getVideoByShortID = `-- name: GetVideoByShortID :one
SELECT id, short_id, title, description, filename, thumbnail_filename, original_filename, storage_path, file_size_bytes, duration_seconds, uploaded_by, category_id, view_count, processing_status, error_message, created_at FROM videos WHERE short_id = $1
`

func (q *Queries) GetVideoByShortID(ctx context.Context, shortID string) (Video, error) {
	row := q.db.QueryRow(ctx, getVideoByShortID, shortID)
	var i Video
	err := row.Scan(
		&i.ID,
		&i.ShortID,
		&i.Title,
		&i.Description,
		&i.Filename,
		&i.ThumbnailFilename,
		&i.OriginalFilename,
		&i.StoragePath,
		&i.FileSizeBytes,
		&i.DurationSeconds,
		&i.UploadedBy,
		&i.CategoryID,
		&i.ViewCount,
		&i.ProcessingStatus,
		&i.ErrorMessage,
		&i.CreatedAt,
	)
	return i, err
}

const getVideoByShortIDWithUploader = `-- name: GetVideoByShortIDWithUploader :one
SELECT 
    v.id, v.short_id, v.title, v.description, v.filename, v.thumbnail_filename, v.original_filename, v.storage_path, v.file_size_bytes, v.duration_seconds, v.uploaded_by, v.category_id, v.view_count, v.processing_status, v.error_message, v.created_at,
    u.username as uploader_username,
    c.name as category_name,
    c.slug as category_slug
FROM videos v
JOIN users u ON v.uploaded_by = u.id
LEFT JOIN categories c ON v.category_id = c.id
WHERE v.short_id = $1
`

type GetVideoByShortIDWithUploaderRow struct {
	ID                uuid.UUID               `json:"id"`
	ShortID           string                  `json:"short_id"`
	Title             string                  `json:"title"`
	Description       *string                 `json:"description"`
	Filename          string                  `json:"filename"`
	ThumbnailFilename *string                 `json:"thumbnail_filename"`
	OriginalFilename  string                  `json:"original_filename"`
	StoragePath       *string                 `json:"storage_path"`
	FileSizeBytes     int64                   `json:"file_size_bytes"`
	DurationSeconds   *int32                  `json:"duration_seconds"`
	UploadedBy        uuid.UUID               `json:"uploaded_by"`
	CategoryID        pgtype.UUID             `json:"category_id"`
	ViewCount         int32                   `json:"view_count"`
	ProcessingStatus  domain.ProcessingStatus `json:"processing_status"`
	ErrorMessage      *string                 `json:"error_message"`
	CreatedAt         time.Time               `json:"created_at"`
	UploaderUsername  string                  `json:"uploader_username"`
	CategoryName      *string                 `json:"category_name"`
	CategorySlug      *string                 `json:"category_slug"`
}

// Get video with uploader and category info (no access control - handler checks access)
func (q *Queries) GetVideoByShortIDWithUploader(ctx context.Context, shortID string) (GetVideoByShortIDWithUploaderRow, error) {
	row := q.db.QueryRow(ctx, getVideoByShortIDWithUploader, shortID)
	var i GetVideoByShortIDWithUploaderRow
	err := row.Scan(
		&i.ID,
		&i.ShortID,
		&i.Title,
		&i.Description,
		&i.Filename,
		&i.ThumbnailFilename,
		&i.OriginalFilename,
		&i.StoragePath,
		&i.FileSizeBytes,
		&i.DurationSeconds,
		&i.UploadedBy,
		&i.CategoryID,
		&i.ViewCount,
		&i.ProcessingStatus,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UploaderUsername,
		&i.CategoryName,
		&i.CategorySlug,
	)
	return i, err
}

const getVideoWithUploader = `-- name: GetVideoWithUploader :one
SELECT 
    v.id, v.short_id, v.title, v.description, v.filename, v.thumbnail_filename, v.original_filename, v.storage_path, v.file_size_bytes, v.duration_seconds, v.uploaded_by, v.category_id, v.view_count, v.processing_status, v.error_message, v.created_at,
    u.username as uploader_username,
    c.name as category_name,
    c.slug as category_slug
FROM videos v
JOIN users u ON v.uploaded_by = u.id
LEFT JOIN categories c ON v.category_id = c.id
WHERE v.short_id = $1
`

type GetVideoWithUploaderRow struct {
	ID                uuid.UUID               `json:"id"`
	ShortID           string                  `json:"short_id"`
	Title             string                  `json:"title"`
	Description       *string                 `json:"description"`
	Filename          string                  `json:"filename"`
	ThumbnailFilename *string                 `json:"thumbnail_filename"`
	OriginalFilename  string                  `json:"original_filename"`
	StoragePath       *string                 `json:"storage_path"`
	FileSizeBytes     int64                   `json:"file_size_bytes"`
	DurationSeconds   *int32                  `json:"duration_seconds"`
	UploadedBy        uuid.UUID               `json:"uploaded_by"`
	CategoryID        pgtype.UUID             `json:"category_id"`
	ViewCount         int32                   `json:"view_count"`
	ProcessingStatus  domain.ProcessingStatus `json:"processing_status"`
	ErrorMessage      *string                 `json:"error_message"`
	CreatedAt         time.Time               `json:"created_at"`
	UploaderUsername  string                  `json:"uploader_username"`
	CategoryName      *string                 `json:"category_name"`
	CategorySlug      *string                 `json:"category_slug"`
}

func (q *Queries) GetVideoWithUploader(ctx context.Context, shortID string) (GetVideoWithUploaderRow, error) {
	row := q.db.QueryRow(ctx, getVideoWithUploader, shortID)
	var i GetVideoWithUploaderRow
	err := row.Scan(
		&i.ID,
		&i.ShortID,
		&i.Title,
		&i.Description,
		&i.Filename,
		&i.ThumbnailFilename,
		&i.OriginalFilename,
		&i.StoragePath,
		&i.FileSizeBytes,
		&i.DurationSeconds,
		&i.UploadedBy,
		&i.CategoryID,
		&i.ViewCount,
		&i.ProcessingStatus,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UploaderUsername,
		&i.CategoryName,
		&i.CategorySlug,
	)
	return i, err
}

const incrementViewCount = `-- name: IncrementViewCount :one
UPDATE videos SET view_count = view_count + 1
WHERE id = $1
RETURNING view_count
`

func (q *Queries) IncrementViewCount(ctx context.Context, id uuid.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, incrementViewCount, id)
	var view_count int32
	err := row.Scan(&view_count)
	return view_count, err
}

const listVideos = `-- name: ListVideos :many
SELECT 
    v.id, v.short_id, v.title, v.description, v.filename, v.thumbnail_filename, v.original_filename, v.storage_path, v.file_size_bytes, v.duration_seconds, v.uploaded_by, v.category_id, v.view_count, v.processing_status, v.error_message, v.created_at,
    u.username as uploader_username,
    c.name as category_name,
    c.slug as category_slug
FROM videos v
JOIN users u ON v.uploaded_by = u.id
LEFT JOIN categories c ON v.category_id = c.id
WHERE 
    ($1::uuid IS NULL OR v.category_id = $1)
    AND ($2::text IS NULL OR v.processing_status::text = $2)
    AND ($3::uuid IS NULL OR v.uploaded_by = $3)
    AND (
        $4::text IS NULL OR $4 = '' OR
        LOWER(v.title) LIKE '%' || LOWER($4) || '%' OR
        LOWER(v.description) LIKE '%' || LOWER($4) || '%'
    )
ORDER BY
    CASE WHEN $5 = 'created_at' AND $6 = 'desc' THEN v.created_at END DESC,
    CASE WHEN $5 = 'created_at' AND $6 = 'asc' THEN v.created_at END ASC,
    CASE WHEN $5 = 'title' AND $6 = 'desc' THEN v.title END DESC,
    CASE WHEN $5 = 'title' AND $6 = 'asc' THEN v.title END ASC,
    CASE WHEN $5 = 'view_count' AND $6 = 'desc' THEN v.view_count END DESC,
    CASE WHEN $5 = 'view_count' AND $6 = 'asc' THEN v.view_count END ASC,
    v.created_at DESC
LIMIT $7 OFFSET $8
`

type ListVideosParams struct {
	Column1 uuid.UUID   `json:"column_1"`
	Column2 string      `json:"column_2"`
	Column3 uuid.UUID   `json:"column_3"`
	Column4 string      `json:"column_4"`
	Column5 interface{} `json:"column_5"`
	Column6 interface{} `json:"column_6"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

type ListVideosRow struct {
	ID                uuid.UUID               `json:"id"`
	ShortID           string                  `json:"short_id"`
	Title             string                  `json:"title"`
	Description       *string                 `json:"description"`
	Filename          string                  `json:"filename"`
	ThumbnailFilename *string                 `json:"thumbnail_filename"`
	OriginalFilename  string                  `json:"original_filename"`
	StoragePath       *string                 `json:"storage_path"`
	FileSizeBytes     int64                   `json:"file_size_bytes"`
	DurationSeconds   *int32                  `json:"duration_seconds"`
	UploadedBy        uuid.UUID               `json:"uploaded_by"`
	CategoryID        pgtype.UUID             `json:"category_id"`
	ViewCount         int32                   `json:"view_count"`
	ProcessingStatus  domain.ProcessingStatus `json:"processing_status"`
	ErrorMessage      *string                 `json:"error_message"`
	CreatedAt         time.Time               `json:"created_at"`
	UploaderUsername  string                  `json:"uploader_username"`
	CategoryName      *string                 `json:"category_name"`
	CategorySlug      *string                 `json:"category_slug"`
}

func (q *Queries) ListVideos(ctx context.Context, arg ListVideosParams) ([]ListVideosRow, error) {
	rows, err := q.db.Query(ctx, listVideos,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListVideosRow{}
	for rows.Next() {
		var i ListVideosRow
		if err := rows.Scan(
			&i.ID,
			&i.ShortID,
			&i.Title,
			&i.Description,
			&i.Filename,
			&i.ThumbnailFilename,
			&i.OriginalFilename,
			&i.StoragePath,
			&i.FileSizeBytes,
			&i.DurationSeconds,
			&i.UploadedBy,
			&i.CategoryID,
			&i.ViewCount,
			&i.ProcessingStatus,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UploaderUsername,
			&i.CategoryName,
			&i.CategorySlug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVideosWithAccess = `-- name: ListVideosWithAccess :many
SELECT 
    v.id, v.short_id, v.title, v.description, v.filename, v.thumbnail_filename, v.original_filename, v.storage_path, v.file_size_bytes, v.duration_seconds, v.uploaded_by, v.category_id, v.view_count, v.processing_status, v.error_message, v.created_at,
    u.username as uploader_username,
    c.name as category_name,
    c.slug as category_slug
FROM videos v
JOIN users u ON v.uploaded_by = u.id
LEFT JOIN categories c ON v.category_id = c.id
WHERE 
    -- Access control: admin sees all, others see completed or own
    ($1::bool = true OR v.processing_status = 'completed' OR v.uploaded_by = $2)
    -- Filters (all optional)
    AND ($3::uuid IS NULL OR v.category_id = $3)
    AND ($4::text IS NULL OR v.processing_status::text = $4)
    AND ($5::uuid IS NULL OR v.uploaded_by = $5)
    AND ($6::text IS NULL OR $6 = '' OR LOWER(v.title) LIKE '%' || LOWER($6) || '%')
ORDER BY
    CASE WHEN $7 = 'created_at' AND $8 = 'desc' THEN v.created_at END DESC,
    CASE WHEN $7 = 'created_at' AND $8 = 'asc' THEN v.created_at END ASC,
    CASE WHEN $7 = 'title' AND $8 = 'desc' THEN v.title END DESC,
    CASE WHEN $7 = 'title' AND $8 = 'asc' THEN v.title END ASC,
    CASE WHEN $7 = 'view_count' AND $8 = 'desc' THEN v.view_count END DESC,
    CASE WHEN $7 = 'view_count' AND $8 = 'asc' THEN v.view_count END ASC,
    v.created_at DESC
LIMIT $9 OFFSET $10
`

type ListVideosWithAccessParams struct {
	Column1    bool        `json:"column_1"`
	UploadedBy uuid.UUID   `json:"uploaded_by"`
	Column3    uuid.UUID   `json:"column_3"`
	Column4    string      `json:"column_4"`
	Column5    uuid.UUID   `json:"column_5"`
	Column6    string      `json:"column_6"`
	Column7    interface{} `json:"column_7"`
	Column8    interface{} `json:"column_8"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
}

type ListVideosWithAccessRow struct {
	ID                uuid.UUID               `json:"id"`
	ShortID           string                  `json:"short_id"`
	Title             string                  `json:"title"`
	Description       *string                 `json:"description"`
	Filename          string                  `json:"filename"`
	ThumbnailFilename *string                 `json:"thumbnail_filename"`
	OriginalFilename  string                  `json:"original_filename"`
	StoragePath       *string                 `json:"storage_path"`
	FileSizeBytes     int64                   `json:"file_size_bytes"`
	DurationSeconds   *int32                  `json:"duration_seconds"`
	UploadedBy        uuid.UUID               `json:"uploaded_by"`
	CategoryID        pgtype.UUID             `json:"category_id"`
	ViewCount         int32                   `json:"view_count"`
	ProcessingStatus  domain.ProcessingStatus `json:"processing_status"`
	ErrorMessage      *string                 `json:"error_message"`
	CreatedAt         time.Time               `json:"created_at"`
	UploaderUsername  string                  `json:"uploader_username"`
	CategoryName      *string                 `json:"category_name"`
	CategorySlug      *string                 `json:"category_slug"`
}

// Non-admin: only COMPLETED videos OR own videos
// Admin: all videos (is_admin = true)
func (q *Queries) ListVideosWithAccess(ctx context.Context, arg ListVideosWithAccessParams) ([]ListVideosWithAccessRow, error) {
	rows, err := q.db.Query(ctx, listVideosWithAccess,
		arg.Column1,
		arg.UploadedBy,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
		arg.Column8,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListVideosWithAccessRow{}
	for rows.Next() {
		var i ListVideosWithAccessRow
		if err := rows.Scan(
			&i.ID,
			&i.ShortID,
			&i.Title,
			&i.Description,
			&i.Filename,
			&i.ThumbnailFilename,
			&i.OriginalFilename,
			&i.StoragePath,
			&i.FileSizeBytes,
			&i.DurationSeconds,
			&i.UploadedBy,
			&i.CategoryID,
			&i.ViewCount,
			&i.ProcessingStatus,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UploaderUsername,
			&i.CategoryName,
			&i.CategorySlug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVideosWithoutHLS = `-- name: ListVideosWithoutHLS :many
SELECT id, short_id, title, description, filename, thumbnail_filename, original_filename, storage_path, file_size_bytes, duration_seconds, uploaded_by, category_id, view_count, processing_status, error_message, created_at FROM videos
WHERE processing_status = 'completed'
AND filename NOT LIKE '%/master.m3u8'
ORDER BY created_at ASC
`

func (q *Queries) ListVideosWithoutHLS(ctx context.Context) ([]Video, error) {
	rows, err := q.db.Query(ctx, listVideosWithoutHLS)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Video{}
	for rows.Next() {
		var i Video
		if err := rows.Scan(
			&i.ID,
			&i.ShortID,
			&i.Title,
			&i.Description,
			&i.Filename,
			&i.ThumbnailFilename,
			&i.OriginalFilename,
			&i.StoragePath,
			&i.FileSizeBytes,
			&i.DurationSeconds,
			&i.UploadedBy,
			&i.CategoryID,
			&i.ViewCount,
			&i.ProcessingStatus,
			&i.ErrorMessage,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateVideo = `-- name: UpdateVideo :one
UPDATE videos SET
    title = COALESCE(NULLIF($2, ''), title),
    description = $3,
    category_id = $4
WHERE id = $1
RETURNING id, short_id, title, description, filename, thumbnail_filename, original_filename, storage_path, file_size_bytes, duration_seconds, uploaded_by, category_id, view_count, processing_status, error_message, created_at
`

type UpdateVideoParams struct {
	ID          uuid.UUID   `json:"id"`
	Column2     interface{} `json:"column_2"`
	Description *string     `json:"description"`
	CategoryID  pgtype.UUID `json:"category_id"`
}

func (q *Queries) UpdateVideo(ctx context.Context, arg UpdateVideoParams) (Video, error) {
	row := q.db.QueryRow(ctx, updateVideo,
		arg.ID,
		arg.Column2,
		arg.Description,
		arg.CategoryID,
	)
	var i Video
	err := row.Scan(
		&i.ID,
		&i.ShortID,
		&i.Title,
		&i.Description,
		&i.Filename,
		&i.ThumbnailFilename,
		&i.OriginalFilename,
		&i.StoragePath,
		&i.FileSizeBytes,
		&i.DurationSeconds,
		&i.UploadedBy,
		&i.CategoryID,
		&i.ViewCount,
		&i.ProcessingStatus,
		&i.ErrorMessage,
		&i.CreatedAt,
	)
	return i, err
}

const updateVideoProcessing = `-- name: UpdateVideoProcessing :one
UPDATE videos SET
    processing_status = $2,
    error_message = $3,
    duration_seconds = $4,
    file_size_bytes = COALESCE($5, file_size_bytes),
    filename = COALESCE(NULLIF($6, ''), filename),
    thumbnail_filename = COALESCE(NULLIF($7, ''), thumbnail_filename)
WHERE id = $1
RETURNING id, short_id, title, description, filename, thumbnail_filename, original_filename, storage_path, file_size_bytes, duration_seconds, uploaded_by, category_id, view_count, processing_status, error_message, created_at
`

type UpdateVideoProcessingParams struct {
	ID               uuid.UUID               `json:"id"`
	ProcessingStatus domain.ProcessingStatus `json:"processing_status"`
	ErrorMessage     *string                 `json:"error_message"`
	DurationSeconds  *int32                  `json:"duration_seconds"`
	FileSizeBytes    int64                   `json:"file_size_bytes"`
	Column6          interface{}             `json:"column_6"`
	Column7          interface{}             `json:"column_7"`
}

func (q *Queries) UpdateVideoProcessing(ctx context.Context, arg UpdateVideoProcessingParams) (Video, error) {
	row := q.db.QueryRow(ctx, updateVideoProcessing,
		arg.ID,
		arg.ProcessingStatus,
		arg.ErrorMessage,
		arg.DurationSeconds,
		arg.FileSizeBytes,
		arg.Column6,
		arg.Column7,
	)
	var i Video
	err := row.Scan(
		&i.ID,
		&i.ShortID,
		&i.Title,
		&i.Description,
		&i.Filename,
		&i.ThumbnailFilename,
		&i.OriginalFilename,
		&i.StoragePath,
		&i.FileSizeBytes,
		&i.DurationSeconds,
		&i.UploadedBy,
		&i.CategoryID,
		&i.ViewCount,
		&i.ProcessingStatus,
		&i.ErrorMessage,
		&i.CreatedAt,
	)
	return i, err
}

const videoExistsByShortID = `-- name: VideoExistsByShortID :one
SELECT EXISTS(SELECT 1 FROM videos WHERE short_id = $1)
`

func (q *Queries) VideoExistsByShortID(ctx context.Context, shortID string) (bool, error) {
	row := q.db.QueryRow(ctx, videoExistsByShortID, shortID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
